//! Era and epoch notification processing logic.
use crate::{metrics, NotificationProcessor, CONFIG};
use anyhow::Context;
use futures_util::StreamExt as _;
use std::str::FromStr;
use subvt_types::app::{notification::NotificationPeriodType, Network};
use subvt_types::substrate::Chain;
use subvt_types::subvt::NetworkStatus;

impl NotificationProcessor {
    /// Subscribes to the network status notifications from Redis (which are generated by
    /// `subvt-network-status-updater`) and processes epoch and era notification at epoch
    /// and era changes.
    pub(crate) async fn start_era_and_epoch_notification_processor(
        &self,
        network: &Network,
    ) -> anyhow::Result<()> {
        log::info!(
            "Start era/epoch notification processor for {}.",
            network.display,
        );
        let redis_url = match Chain::from_str(&network.chain)? {
            Chain::Kusama | Chain::KusamaAssetHub | Chain::KusamaPeople => &CONFIG.redis.kusama_url,
            Chain::Polkadot | Chain::PolkadotAssetHub | Chain::PolkadotPeople => {
                &CONFIG.redis.polkadot_url
            }
            Chain::Westend => &CONFIG.redis.westend_url,
        };
        let redis = redis::Client::open(redis_url.as_str()).context(format!(
            "Cannot connect to {} Redis at URL {redis_url}.",
            network.display,
        ))?;
        let mut data_connection = redis.get_multiplexed_async_connection().await?;
        let mut pubsub_connection = redis.get_async_pubsub().await?;
        let mut maybe_active_era_index: Option<u32> = None;
        let mut maybe_current_epoch_index: Option<u64> = None;
        pubsub_connection
            .subscribe(format!(
                "subvt:{}:network_status:publish:best_block_number",
                network.display.to_lowercase(),
            ))
            .await?;
        let mut pubsub_stream = pubsub_connection.on_message();
        loop {
            let _ = pubsub_stream.next().await;
            let key = format!("subvt:{}:network_status", network.display.to_lowercase());
            let status_json_string: String = redis::cmd("GET")
                .arg(key)
                .query_async(&mut data_connection)
                .await?;
            let status: NetworkStatus = serde_json::from_str(&status_json_string)?;
            log::info!(
                "New {} status, best block #{}.",
                network.display,
                status.best_block_number,
            );

            // process epoch notifications if epoch has changed
            let epoch_index = match maybe_current_epoch_index {
                Some(epoch_index) => epoch_index,
                None => {
                    maybe_current_epoch_index = Some(status.current_epoch.index);
                    status.current_epoch.index
                }
            };
            if epoch_index != status.current_epoch.index {
                let epoch_number_in_era =
                    (status.current_epoch.index % CONFIG.substrate.epochs_per_era as u64) + 1;
                log::info!(
                    "New {} epoch index {}. Epoch number {} in era. Check for notifications.",
                    network.display,
                    status.current_epoch.index,
                    epoch_number_in_era,
                );
                match self
                    .process_notifications(
                        Some(network.id),
                        NotificationPeriodType::Epoch,
                        epoch_number_in_era as u32,
                    )
                    .await
                {
                    Ok(_) => {
                        metrics::epoch_index(&network.chain).set(status.current_epoch.index as i64);
                    }
                    Err(error) => {
                        log::error!(
                            "Error while processing {} epoch #{} notifications: {:?}",
                            network.display,
                            status.current_epoch.index,
                            error,
                        );
                    }
                }
                maybe_current_epoch_index = Some(status.current_epoch.index);
            }

            // process era notifications if era has changed
            let era_index = match maybe_active_era_index {
                Some(era_index) => era_index,
                None => {
                    maybe_active_era_index = Some(status.active_era.index);
                    status.active_era.index
                }
            };
            if era_index != status.active_era.index {
                log::info!(
                    "New {} era #{}. Check for notifications.",
                    network.display,
                    status.active_era.index,
                );
                match self
                    .process_notifications(
                        Some(network.id),
                        NotificationPeriodType::Era,
                        status.active_era.index,
                    )
                    .await
                {
                    Ok(_) => {
                        metrics::era_index(&network.chain).set(status.active_era.index as i64);
                    }
                    Err(error) => {
                        log::error!(
                            "Error while processing era #{} notifications: {:?}",
                            status.active_era.index,
                            error,
                        );
                    }
                }
                maybe_active_era_index = Some(status.active_era.index);
            }
        }
    }
}
